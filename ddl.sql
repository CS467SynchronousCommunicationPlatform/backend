-- create table statements generated using definition tab from supabase

-- users table
create table
  public.users (
    id uuid not null,
    created_at timestamp without time zone null,
    display_name text not null,
    constraint users_pkey primary key (id),
    constraint users_display_name_key unique (display_name),
    constraint users_id_fkey foreign key (id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

-- channels table
create table
  public.channels (
    id bigint generated by default as identity not null,
    name character varying not null,
    created_at timestamp with time zone not null default now(),
    description character varying not null,
    private boolean not null,
    constraint channels_pkey primary key (id),
    constraint channels_name_key unique (name)
  ) tablespace pg_default;

insert into public.channels (name, description, private) values (
  'General Chat',
  'Landing page for all new users. Welcome!',
  false
);

-- messages table
create table
  public.messages (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone not null default now(),
    body text null,
    user_id uuid null,
    constraint messages_pkey primary key (id),
    constraint messages_user_id_fkey foreign key (user_id) references users (id) on update cascade on delete set null
  ) tablespace pg_default;

-- channels_messages table
create table
  public.channels_messages (
    id bigint generated by default as identity not null,
    channel_id bigint not null,
    message_id bigint not null,
    constraint channels_messages_pkey primary key (id),
    constraint channels_messages_channel_id_fkey foreign key (channel_id) references channels (id) on update cascade on delete cascade,
    constraint channels_messages_message_id_fkey foreign key (message_id) references messages (id) on update cascade on delete cascade
  ) tablespace pg_default;

create unique index if not exists channel_message on public.channels_messages using btree (channel_id, message_id) tablespace pg_default;

-- channels_users table
create table
  public.channels_users (
    id bigint generated by default as identity not null,
    channel_id bigint not null,
    user_id uuid not null,
    unread bigint not null default '0'::bigint,
    constraint channels_users_pkey primary key (id),
    constraint channels_users_channel_id_fkey foreign key (channel_id) references channels (id) on update cascade on delete cascade,
    constraint channels_users_user_id_fkey foreign key (user_id) references users (id) on update cascade on delete cascade
  ) tablespace pg_default;

create unique index if not exists channel_user on public.channels_users using btree (channel_id, user_id) tablespace pg_default;

-- notification functions
create function clearnotifications(userid uuid, channelid integer)
returns record
language sql
as $$
  update channels_users 
  set unread = 0
  where user_id = userId
  and channel_id = channelId;

  select * from channels_users
  where user_id = userId and channel_id = channelId;
$$;

create function incrementnotifications(userid uuid, channelid integer)
returns record
language sql
as $$
  update channels_users 
  set unread = unread + 1
  where user_id = userId
  and channel_id = channelId;

  select * from channels_users
  where user_id = userId and channel_id = channelId;
$$;

-- based on example from https://supabase.com/docs/guides/auth/managing-user-data
-- new user trigger
create function handle_new_user()
returns trigger
language plpgsql
security definer
as $$
begin
  if exists (select from public.users where display_name = new.raw_user_meta_data ->> 'name') then
    insert into public.users (id, created_at, display_name)
    values (new.id, new.created_at, new.raw_user_meta_data ->> 'email');
  else
    insert into public.users (id, created_at, display_name)
    values (new.id, new.created_at, new.raw_user_meta_data ->> 'name');
  end if;
  insert into public.channels_users (channel_id, user_id)
  values ((select id from public.channels where name = 'General Chat'), new.id);
  return new;
end;
$$;

create trigger on_auth_user_created
after insert on auth.users
for each row
execute function handle_new_user();